"""
Unified CLI for LangGraph Knowledge Graph System

A comprehensive command-line interface that combines faculty approval workflows,
automatic pipelines, and technical orchestration in a single, unified system.

FACULTY WORKFLOWS (Primary Interface):
    python main.py faculty-start --course_id CSN --faculty_id PROF_123    # Start faculty workflow
    python main.py faculty-approve --course_id CSN --action approve       # Faculty approve LOs
    python main.py faculty-confirm --course_id CSN --action confirm       # Faculty confirm structure  
    python main.py faculty-finalize --course_id CSN --action finalize     # Faculty finalize KG
    python main.py faculty-status --course_id CSN                         # Check workflow status
    python main.py learner-plt --course_id CSN --learner_id R001          # Generate PLT for learner

AUTOMATIC PIPELINES (No Faculty Input):
    python main.py auto                    # Run complete automatic pipeline  
    python main.py auto --course_id CSN    # Auto pipeline for specific course
    python main.py content --course_id CSN # Content-only automatic pipeline
    python main.py learner --learner_id R001 # Learner-only automatic pipeline

TECHNICAL COMMANDS (Service Orchestration):
    python main.py cross --course_id CSN --learner_id R001                # Cross-subsystem workflow
    python main.py services --list                                        # List all registered services
    python main.py services --subsystem content                           # List content services

LEGACY COMMANDS (Backward Compatibility):
    python main.py stage1                  # Manual Stage 1 only
    python main.py stage2                  # Manual Stage 2 only  
    python main.py plt                     # Manual PLT only
    python main.py es                      # Manual ES pipeline
    python main.py unified                 # Legacy unified pipeline
"""

import sys
import time
from pathlib import Path

# Add project root to path for imports
sys.path.append(str(Path(__file__).parent))

from langchain_core.messages import HumanMessage
from graph.graph import build_graph_stage_1, build_graph_stage_2
from graph.plt_generator import run_plt_generator
from utils.database_manager import insert_plt_to_neo4j, get_plt_for_learner
from graph.utils.es_to_kg import transform_es_to_kg, validate_es_connection, get_es_chunk_count
from utils.database_manager import insert_course_kg_to_neo4j, clear_neo4j_database
# Removed unused import: from graph.orchestrator import run_course_pipeline

# Import automatic pipeline coordinator (for testing/development)
from pipeline.automatic_coordinator import run_automatic_pipeline, process_course_content, generate_learner_plt
from config.loader import get_default_course_id, get_default_learner_id
from utils.logging import get_orchestrator_logger

# Import manual approval pipeline coordinator (for production)
from pipeline.manual_coordinator import (
    start_faculty_workflow, faculty_approve_course, process_content_after_course_approval,
    faculty_approve, faculty_confirm, faculty_finalize,
    manual_coordinator
)

# Import orchestrator components for service registration
from orchestrator.service_registry import get_service_registry, reset_service_registry
from orchestrator.state import UniversalState, SubsystemType, ServiceDefinition, SubsystemDefinition
from orchestrator.universal_orchestrator import UniversalOrchestrator, run_cross_subsystem_workflow

# Enhanced logger
logger = get_orchestrator_logger("main_cli")

def register_all_services():
    """Register all available services across subsystems."""
    registry = get_service_registry()
    
    print("[SYSTEM] Registering services across all subsystems...")
    
    # ===== CONTENT SUBSYSTEM =====
    print("[CONTENT] Registering Content Subsystem services...")
    
    try:
        from subsystems.content.services.course_manager import create_course_manager_service
        course_manager = create_course_manager_service()
        registry.register_service(course_manager.get_service_definition(), SubsystemType.CONTENT)
    except ImportError as e:
        print(f"[WARNING] Could not register course_manager: {e}")
    
    try:
        from subsystems.content.services.content_preprocessor import create_content_preprocessor_service
        content_preprocessor = create_content_preprocessor_service()
        registry.register_service(content_preprocessor.get_service_definition(), SubsystemType.CONTENT)
    except ImportError as e:
        print(f"[WARNING] Could not register content_preprocessor: {e}")
    
    try:
        from subsystems.content.services.course_mapper import create_course_mapper_service
        course_mapper = create_course_mapper_service()
        registry.register_service(course_mapper.get_service_definition(), SubsystemType.CONTENT)
    except ImportError as e:
        print(f"[WARNING] Could not register course_mapper: {e}")
    
    try:
        from subsystems.content.services.kli_application import create_kli_application_service
        kli_application = create_kli_application_service()
        registry.register_service(kli_application.get_service_definition(), SubsystemType.CONTENT)
    except ImportError as e:
        print(f"[WARNING] Could not register kli_application: {e}")
    
    try:
        from subsystems.content.services.knowledge_graph_generator import create_knowledge_graph_generator_service
        kg_generator = create_knowledge_graph_generator_service()
        registry.register_service(kg_generator.get_service_definition(), SubsystemType.CONTENT)
    except ImportError as e:
        print(f"[WARNING] Could not register knowledge_graph_generator: {e}")
    
    # Register content subsystem definition
    content_services = [s for s in registry.services.values() if s.subsystem == SubsystemType.CONTENT]
    if content_services:
        content_subsystem = SubsystemDefinition(
            subsystem_type=SubsystemType.CONTENT,
            name="Content Subsystem",
            description="Handles course content processing and knowledge graph generation",
            services=content_services,
            entry_points=["course_manager"]
        )
        registry.register_subsystem(content_subsystem)
    
    # ===== LEARNER SUBSYSTEM =====
    print("[LEARNER] Registering Learner Subsystem services...")
    
    try:
        from subsystems.learner.services.learning_tree_handler import create_learning_tree_handler_service
        learning_tree_handler = create_learning_tree_handler_service()
        registry.register_service(learning_tree_handler.get_service_definition(), SubsystemType.LEARNER)
    except ImportError as e:
        print(f"[WARNING] Could not register learning_tree_handler: {e}")
    
    try:
        from subsystems.learner.services.graph_query_engine import create_graph_query_engine_service
        graph_query_engine = create_graph_query_engine_service()
        registry.register_service(graph_query_engine.get_service_definition(), SubsystemType.LEARNER)
    except ImportError as e:
        print(f"[WARNING] Could not register graph_query_engine: {e}")
    
    try:
        from subsystems.learner.services.query_strategy_manager import create_query_strategy_manager_service
        query_strategy_manager = create_query_strategy_manager_service()
        registry.register_service(query_strategy_manager.get_service_definition(), SubsystemType.LEARNER)
    except ImportError as e:
        print(f"[WARNING] Could not register query_strategy_manager: {e}")
    
    # Register learner subsystem definition
    learner_services = [s for s in registry.services.values() if s.subsystem == SubsystemType.LEARNER]
    if learner_services:
        learner_subsystem = SubsystemDefinition(
            subsystem_type=SubsystemType.LEARNER,
            name="Learner Subsystem", 
            description="Handles learner personalization and learning path generation",
            services=learner_services,
            entry_points=["query_strategy_manager"]
        )
        registry.register_subsystem(learner_subsystem)
    
    # ===== SME SUBSYSTEM =====
    print("[SME] Registering SME Subsystem services...")
    # SME services would be registered here when implemented
    
    # ===== ANALYTICS SUBSYSTEM =====
    print("[ANALYTICS] Registering Analytics Subsystem services...")
    # Analytics services would be registered here when implemented
    
    print(f"[SUCCESS] Service registration completed: {len(registry.services)} services registered")
    
    return registry

def run_automatic_pipeline_cmd(args):
    """
    Run the complete automatic pipeline - REPLACES manual CLI invocation.
    
    This is the new recommended way to run the system.
    """
    logger.info("Starting automatic pipeline execution", 
                course_id=args.course_id,
                source=args.source,
                learner_id=getattr(args, 'learner_id', None))
    
    try:
        # Prepare pipeline arguments
        pipeline_kwargs = {
            "content_source": args.source,
            "course_id": args.course_id,
            "generate_plt": getattr(args, 'generate_plt', True)
        }
        
        # Add source-specific arguments
        if args.source == "pdf" and hasattr(args, 'file_path') and args.file_path:
            pipeline_kwargs["file_path"] = args.file_path
        elif args.source == "elasticsearch":
            pipeline_kwargs["es_index"] = getattr(args, 'es_index', 'advanced_docs_elasticsearch_v2')
        elif args.source == "llm_generated":
            pipeline_kwargs["raw_content"] = getattr(args, 'raw_content', '')
        
        # Add learner information if specified
        if hasattr(args, 'learner_id') and args.learner_id:
            pipeline_kwargs["learner_id"] = args.learner_id
        
        # Execute automatic pipeline
        print("[PIPELINE] Running Automatic LangGraph Pipeline")
        print("=" * 50)
        print(f"[COURSE] {args.course_id}")
        print(f"[SOURCE] {args.source}")
        if pipeline_kwargs.get("learner_id"):
            print(f"[LEARNER] {pipeline_kwargs['learner_id']}")
        print("=" * 50)
        
        result = run_automatic_pipeline(**pipeline_kwargs)
        
        # Display results
        if result["status"] == "completed":
            print("\n[SUCCESS] Automatic Pipeline Completed Successfully!")
            print(f"[PIPELINE_TYPE] {result['pipeline_type']}")
            print(f"[COURSE_ID] {result['course_id']}")
            
            if "content_pipeline" in result:
                content_status = result["content_pipeline"]["status"]
                print(f"[CONTENT] Pipeline: {content_status}")
                if content_status == "completed":
                    stages = result["content_pipeline"].get("stages", [])
                    print(f"   Stages: {' -> '.join(stages)}")
            
            if "learner_pipeline" in result and result["learner_pipeline"]:
                learner_status = result["learner_pipeline"]["status"]
                print(f"[LEARNER] Pipeline: {learner_status}")
                if learner_status == "completed":
                    print(f"   Learner: {result['learner_id']}")
            
            print("\n[COMPLETE] All stages completed automatically!")
        else:
            print(f"\n[ERROR] Pipeline failed: {result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="automatic_pipeline_cmd")
        print(f"[ERROR] Automatic pipeline failed: {e}")

def run_content_only_cmd(args):
    """Run content-only automatic pipeline."""
    logger.info("Starting content-only pipeline", course_id=args.course_id, source=args.source)
    
    try:
        print("[CONTENT] Running Content-Only Automatic Pipeline")
        print("=" * 50)
        
        result = process_course_content(
            course_id=args.course_id,
            content_source=args.source,
            file_path=getattr(args, 'file_path', None),
            es_index=getattr(args, 'es_index', 'advanced_docs_elasticsearch_v2'),
            raw_content=getattr(args, 'raw_content', '')
        )
        
        if result["status"] == "completed":
            print("âœ… Content pipeline completed successfully!")
            print(f"ğŸ“š Course: {result['course_id']}")
            print(f"ğŸ“ Source: {result['source']}")
            stages = result.get("stages", [])
            print(f"ğŸ”„ Stages: {' â†’ '.join(stages)}")
        else:
            print(f"âŒ Content pipeline failed: {result.get('error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="content_only_cmd")
        print(f"âŒ Content pipeline failed: {e}")

def run_learner_only_cmd(args):
    """Run learner-only automatic pipeline."""
    logger.info("Starting learner-only pipeline", 
                course_id=args.course_id, 
                learner_id=args.learner_id)
    
    try:
        print("ğŸ‘¤ Running Learner-Only Automatic Pipeline")
        print("=" * 50)
        
        result = generate_learner_plt(
            course_id=args.course_id,
            learner_id=args.learner_id
        )
        
        if result["status"] == "completed":
            print("âœ… Learner pipeline completed successfully!")
            print(f"ğŸ“š Course: {result['course_id']}")
            print(f"ğŸ‘¤ Learner: {result['learner_id']}")
            stages = result.get("stages", [])
            print(f"ğŸ”„ Stages: {' â†’ '.join(stages)}")
        else:
            print(f"âŒ Learner pipeline failed: {result.get('error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="learner_only_cmd")
        print(f"âŒ Learner pipeline failed: {e}")

def run_faculty_start_cmd(args):
    """Start a new faculty approval workflow."""
    logger.info("Starting faculty approval workflow",
                course_id=args.course_id,
                faculty_id=args.faculty_id)
    
    try:
        print("ğŸ”µ Starting Faculty Approval Workflow")
        print("=" * 50)
        print(f"ğŸ“š Course: {args.course_id}")
        print(f"ğŸ‘¨â€ğŸ« Faculty: {args.faculty_id}")
        print("=" * 50)
        
        result = start_faculty_workflow(
            course_id=args.course_id,
            faculty_id=args.faculty_id,
            content_source=args.source,
            file_path=getattr(args, 'file_path', None),
            es_index=getattr(args, 'es_index', 'advanced_docs_elasticsearch_v2'),
            raw_content=getattr(args, 'raw_content', '')
        )
        
        if result["status"] == "awaiting_faculty_approval":
            if result["stage"] == "course_initialization_approval":
                print("âœ… Course Manager completed course initialization!")
                print("\n" + result["ui_data"]["approval_stage"])
                print("ğŸ“‹ " + result["ui_data"]["instructions"])
                print(f"ğŸ¯ Next Action: {result['next_action_required']}")
                print(f"ğŸ“ Available Actions: {', '.join(result['ui_data']['actions'])}")
                
                print("\nğŸ“‹ Course Details:")
                course_details = result["ui_data"]["course_details"]
                print(f"   Course ID: {course_details['course_id']}")
                print(f"   Faculty ID: {course_details['faculty_id']}")
                print(f"   Content Source: {course_details['content_source']}")
                print(f"   Status: {course_details['initialization_status']}")
                
                print(f"\nğŸ”„ Use: python main.py faculty-approve-course --course_id {args.course_id} --action approve")
                
            elif result["stage"] == "lo_approval":
                print("âœ… Content processed and Learning Objectives generated!")
                print(f"ğŸ“ Generated {len(result['draft_learning_objectives'])} Learning Objectives")
                print("\n" + result["ui_data"]["approval_stage"])
                print("ğŸ“‹ " + result["ui_data"]["instructions"])
                print(f"ğŸ¯ Next Action: {result['next_action_required']}")
                
                print("\nğŸ“š Draft Learning Objectives:")
                for i, lo in enumerate(result['draft_learning_objectives'][:3], 1):
                    print(f"   {i}. {lo.get('text', 'N/A')}")
                if len(result['draft_learning_objectives']) > 3:
                    print(f"   ... and {len(result['draft_learning_objectives']) - 3} more")
                    
                print(f"\nğŸ”„ Use: python main.py faculty-approve --course_id {args.course_id} --action approve")
            
        else:
            print(f"âŒ Workflow failed: {result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="faculty_start_cmd")
        print(f"âŒ Faculty workflow start failed: {e}")

def run_faculty_approve_course_cmd(args):
    """Process faculty approval of course setup."""
    logger.info("Processing faculty course setup approval",
                course_id=args.course_id,
                action=args.action)
    
    try:
        print("ğŸ”µ Faculty Course Setup Approval")
        print("=" * 50)
        
        result = faculty_approve_course(
            course_id=args.course_id,
            action=args.action,
            faculty_comments=getattr(args, 'comments', '')
        )
        
        if result["status"] == "course_approved":
            print("âœ… Course setup APPROVED!")
            print("ğŸ“š Proceeding to Content Processing + LO Generation + Structure Generation...")
            print("ğŸ”„ This will take a few minutes...")
            
            # Automatically proceed to content processing and structure generation
            content_result = process_content_after_course_approval(args.course_id)
            
            if content_result["status"] == "awaiting_faculty_confirmation":
                print("âœ… Content processed and course structure generated!")
                print("ï¿½ Complete course structure ready for faculty confirmation")
                print("\n" + content_result["ui_data"]["approval_stage"])
                print("ğŸ“‹ " + content_result["ui_data"]["instructions"])
                
                print("\nğŸ“š Draft Learning Objectives:")
                for i, lo in enumerate(content_result['draft_learning_objectives'][:3], 1):
                    print(f"   {i}. {lo.get('text', 'N/A')}")
                if len(content_result['draft_learning_objectives']) > 3:
                    print(f"   ... and {len(content_result['draft_learning_objectives']) - 3} more")
                    
                print(f"\nğŸ”„ Use: python main.py faculty-approve --course_id {args.course_id} --action approve")
            
        elif result["status"] == "rejected":
            print("âŒ Course initialization rejected.")
            print(f"ğŸ“ Faculty Comments: {result.get('faculty_comments', 'None')}")
            
        else:
            print(f"âŒ Course approval failed: {result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="faculty_approve_course_cmd")
        print(f"âŒ Faculty course approval failed: {e}")

def run_faculty_approve_cmd(args):
    """Process faculty approval of learning objectives."""
    logger.info("Processing faculty learning objectives approval",
                course_id=args.course_id,
                action=args.action)
    
    try:
        print("ğŸ“ Faculty Learning Objectives Approval")
        print("=" * 50)
        
        result = faculty_approve(
            course_id=args.course_id,
            action=args.action,
            faculty_comments=getattr(args, 'comments', '')
        )
        
        if result["status"] == "awaiting_faculty_confirmation":
            print("âœ… Learning Objectives APPROVED!")
            print("ğŸ¯ Course structure generated - awaiting faculty confirmation")
            print("ğŸ“‹ " + result["ui_data"]["approval_stage"])
            print("ğŸ“‹ " + result["ui_data"]["instructions"])
            print(f"ğŸ”„ Use: python main.py faculty-confirm --course_id {args.course_id} --action confirm")
            
        elif result["status"] == "awaiting_faculty_approval":
            print("âœï¸ Learning objectives edited - awaiting re-approval")
            
        elif result["status"] == "rejected":
            print("âŒ Learning Objectives rejected")
            print(f"ğŸ’¬ Comments: {result.get('faculty_comments', 'None')}")
            
        else:
            print(f"âŒ Action failed: {result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="faculty_approve_cmd")
        print(f"âŒ Faculty approval failed: {e}")

def run_faculty_confirm_cmd(args):
    """Process faculty confirmation of course structure."""
    logger.info("Processing faculty course structure confirmation",
                course_id=args.course_id,
                action=args.action)
    
    try:
        print("ğŸ—ï¸ Faculty Course Structure Confirmation")
        print("=" * 50)
        
        result = faculty_confirm(
            course_id=args.course_id,
            action=args.action,
            faculty_comments=getattr(args, 'comments', '')
        )
        
        if result["status"] == "awaiting_faculty_finalization":
            print("âœ… Course Structure CONFIRMED!")
            print("ğŸ“Š Knowledge Graph generated - awaiting faculty finalization")
            print("ğŸ“‹ " + result["ui_data"]["approval_stage"])
            print("ğŸ“‹ " + result["ui_data"]["instructions"])
            print(f"ğŸ”„ Use: python main.py faculty-finalize --course_id {args.course_id} --action finalize")
            
        elif result["status"] == "awaiting_faculty_confirmation":
            print("âœï¸ Course structure edited - awaiting re-confirmation")
            
        elif result["status"] == "rejected":
            print("âŒ Course structure rejected")
            print(f"ğŸ’¬ Comments: {result.get('faculty_comments', 'None')}")
            
        else:
            print(f"âŒ Action failed: {result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="faculty_confirm_cmd")
        print(f"âŒ Faculty confirmation failed: {e}")

def run_faculty_finalize_cmd(args):
    """Process faculty finalization of knowledge graph."""
    logger.info("Processing faculty knowledge graph finalization",
                course_id=args.course_id,
                action=args.action)
    
    try:
        print("ğŸ”¬ Faculty Knowledge Graph Finalization")
        print("=" * 50)
        
        result = faculty_finalize(
            course_id=args.course_id,
            action=args.action,
            faculty_comments=getattr(args, 'comments', '')
        )
        
        if result["status"] == "course_structure_finalized":
            print("âœ… Knowledge Graph FINALIZED!")
            print("ğŸ‰ Faculty workflow completed successfully!")
            print("ğŸ“‹ " + result["ui_data"]["approval_stage"])
            print("ğŸ“‹ " + result["ui_data"]["instructions"])
            print(f"ğŸ¯ Course is now ready for personalized learning tree generation")
            print(f"ğŸ”„ Use: python main.py learner-plt --course_id {args.course_id} --learner_id <LEARNER_ID>")
            
        elif result["status"] == "awaiting_faculty_finalization":
            print("âœï¸ Knowledge graph edited - awaiting re-finalization")
            
        elif result["status"] == "rejected":
            print("âŒ Knowledge Graph rejected")
            print(f"ğŸ’¬ Comments: {result.get('faculty_comments', 'None')}")
            
        else:
            print(f"âŒ Action failed: {result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="faculty_finalize_cmd")
        print(f"âŒ Faculty finalization failed: {e}")

def run_learner_plt_cmd(args):
    """Generate PLT for a specific learner after faculty workflow completion."""
    logger.info("Generating PLT for learner",
                course_id=args.course_id,
                learner_id=args.learner_id)
    
    try:
        print("ğŸŒ³ Generating Personalized Learning Tree (PLT)")
        print("=" * 50)
        print(f"ğŸ“š Course: {args.course_id}")
        print(f"ğŸ‘¤ Learner: {args.learner_id}")
        print("=" * 50)
        
        # Prepare learner context if provided
        learner_context = {}
        if hasattr(args, 'learning_style') and args.learning_style:
            learner_context['learning_style'] = args.learning_style
        if hasattr(args, 'experience_level') and args.experience_level:
            learner_context['experience_level'] = args.experience_level
        if hasattr(args, 'preferences') and args.preferences:
            learner_context['preferences'] = args.preferences
        
        from pipeline.manual_coordinator import manual_coordinator
        result = manual_coordinator.generate_plt_for_learner(
            course_id=args.course_id,
            learner_id=args.learner_id,
            learner_context=learner_context if learner_context else None
        )
        
        if result["status"] == "plt_generated":
            print("âœ… PLT Generated Successfully!")
            print(f"ğŸ“š Course: {result['course_id']}")
            print(f"ğŸ‘¤ Learner: {result['learner_id']}")
            print(f"ğŸ¯ Based on Faculty Finalized Structure: {'âœ…' if result['based_on_ffcs'] else 'âŒ'}")
            if result.get('learner_context'):
                print(f"ğŸ”§ Learner Context Applied: {list(result['learner_context'].keys())}")
            print("\nğŸ‰ Personalized Learning Tree ready for learner!")
            
        else:
            print(f"âŒ PLT generation failed: {result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.log_error_with_context(e, operation="learner_plt_cmd")
        print(f"âŒ PLT generation failed: {e}")

def run_faculty_status_cmd(args):
    """Check faculty approval workflow status."""
    try:
        print("ğŸ“Š Faculty Workflow Status")
        print("=" * 50)
        
        status = manual_coordinator.get_workflow_status(args.course_id)
        
        if status["status"] == "not_found":
            print(f"âŒ No workflow found for course {args.course_id}")
            print("ğŸ”„ Use: python main.py faculty-start to begin a new workflow")
            return
        elif status["status"] == "error":
            print(f"âŒ Error retrieving workflow status: {status.get('error', 'Unknown error')}")
            return
        
        print(f"ğŸ“š Course: {status['course_id']}")
        print(f"ğŸ‘¨â€ğŸ« Faculty: {status['faculty_id']}")
        print(f"ğŸ”„ Current Stage: {status['current_stage']}")
        print(f"â° Last Updated: {status.get('last_updated', 'Unknown')}")
        print(f"ï¿½ FACD Generated: {'âœ…' if status.get('has_facd') else 'âŒ'}")
        print(f"ğŸ—ï¸ FCCS Generated: {'âœ…' if status.get('has_fccs') else 'âŒ'}")
        print(f"ï¿½ FFCS Generated: {'âœ…' if status.get('has_ffcs') else 'âŒ'}")
        print(f"ğŸš€ Ready for PLT: {'âœ…' if status.get('ready_for_plt') else 'âŒ'}")
        
    except Exception as e:
        logger.log_error_with_context(e, operation="faculty_status_cmd")
        print(f"âŒ Status check failed: {e}")

def run_cross_subsystem_workflow_cmd(args):
    """Run cross-subsystem workflow."""
    print("ğŸŒ Running Cross-Subsystem Workflow...")
    
    # Register all services first
    register_all_services()
    
    # Create orchestrator
    orchestrator = UniversalOrchestrator()
    
    # Build initial state for cross-subsystem execution
    initial_state: UniversalState = {
        "course_id": args.course_id,
        "subsystem": SubsystemType.CONTENT,  # Start with content
        "upload_type": args.upload_type,
        "execution_context": {
            "multi_subsystem": True,
            "target_subsystems": ["content", "learner"]
        }
    }
    
    # Add subsystem-specific inputs
    if args.upload_type == "pdf" and args.file_path:
        initial_state["file_path"] = args.file_path
    elif args.upload_type == "elasticsearch" and args.es_index:
        initial_state["es_index"] = args.es_index
    
    # Add learner context if provided
    if args.learner_id:
        initial_state["learner_id"] = args.learner_id
        initial_state["cross_system_payload"] = {
            "service_id": "learning_tree_handler",
            "trigger_after": "course_manager"
        }
        initial_state["source_subsystem"] = SubsystemType.CONTENT
        initial_state["target_subsystem"] = SubsystemType.LEARNER
    
    # Run orchestrator
    result = orchestrator.run(initial_state)
    
    # Display comprehensive results
    print("\nğŸ‰ Cross-Subsystem Workflow Results:")
    print(f"   Session ID: {result.get('session_id')}")
    print(f"   Execution Steps: {len(result.get('execution_history', []))}")
    
    # Service results
    service_statuses = result.get('service_statuses', {})
    completed_services = [sid for sid, status in service_statuses.items() if status == 'completed']
    failed_services = [sid for sid, status in service_statuses.items() if status == 'error']
    
    print(f"   âœ… Completed Services: {completed_services}")
    if failed_services:
        print(f"   âŒ Failed Services: {failed_services}")
    
    return result

def list_services_cmd(args):
    """List all registered services."""
    register_all_services()
    registry = get_service_registry()
    
    services_info = registry.list_services(
        subsystem=SubsystemType(args.subsystem) if args.subsystem else None
    )
    
    print(f"\nğŸ“‹ Registered Services ({len(services_info)} total):")
    print("=" * 80)
    
    for service_id, info in services_info.items():
        print(f"ğŸ”§ {service_id}")
        print(f"   Name: {info['name']}")
        print(f"   Subsystem: {info['subsystem']}")
        print(f"   Description: {info['description']}")
        print(f"   Dependencies: {info['dependencies']}")
        print(f"   Inputs: {info['required_inputs']}")
        print(f"   Outputs: {info['provided_outputs']}")
        print()

# ... keep existing legacy functions for backward compatibility ...
def run_plt_pipeline():
    """Legacy PLT pipeline function (kept for backward compatibility)"""
    learner_id = get_default_learner_id()
    course_id = get_default_course_id()

    try:
        # Step 1: Generate and insert
        print("1ï¸âƒ£ Generating Personalized Learning Tree...")
        result = run_plt_generator()
        plt = result["final_plt"]
        print(f"   âœ… Generated PLT with {len(plt['learning_path'])} steps")
        
        print("\n2ï¸âƒ£ Inserting PLT into Neo4j...")
        insert_plt_to_neo4j(plt, clear_existing=True)
        print("   âœ… Inserted PLT steps into Neo4j (cleared existing data).")

        # Step 2: Query and verify
        print("\n3ï¸âƒ£ Querying and verifying PLT data...")
        steps = get_plt_for_learner(learner_id, course_id)
        print(f"   âœ… Retrieved {len(steps)} PLT steps from Neo4j.")
        
        print(f"\n4ï¸âƒ£ PLT Summary for {learner_id} in {course_id}:")
        print("-" * 50)

        for i, step in enumerate(steps[:5], 1):  # Show first 5 steps
            print(f"   {i}. LO: {step.get('lo', 'N/A')}")
            print(f"      KC: {step.get('kc', 'N/A')}")
            print(f"      Priority: {step.get('priority', 'N/A')}")
            print(f"      Sequence: {step.get('sequence', 'N/A')}")
            print()

        print(f"âœ… PLT Pipeline completed successfully!")
        print(f"ğŸ“Š Generated {len(plt['learning_path'])} learning steps")
        print(f"ğŸ“Š Inserted {len(steps)} steps into Neo4j")

    except Exception as e:
        print(f"âŒ PLT Pipeline failed: {e}")
        import traceback
        traceback.print_exc()

def run_es_pipeline():
    """Legacy ES pipeline function (kept for backward compatibility)"""
    print("ğŸš€ ES to KG to PLT Pipeline")
    print("=" * 50)
    
    # Get user input for configuration
    try:
        course_id = input("Enter course ID (default: OSN): ").strip() or get_default_course_id()
        learner_id = input("Enter learner ID (default: R000): ").strip() or get_default_learner_id()
        generate_plt = input("Generate PLT after KG insertion? (y/n, default: y): ").strip().lower() != "n"
        clear_existing = input("Clear existing KG data? (y/n, default: n): ").strip().lower() == "y"
    except Exception as e:
        print(f"âš ï¸ Using defaults due to input error: {e}")
        course_id = get_default_course_id()
        learner_id = get_default_learner_id()
        generate_plt = True
        clear_existing = False
    
    try:
        # Step 1: Validate Elasticsearch connection
        print(f"\n1ï¸âƒ£ Validating Elasticsearch connection...")
        if not validate_es_connection():
            print("âŒ Elasticsearch validation failed. Please check your ES setup.")
            return
        
        # Get chunk count
        chunk_count = get_es_chunk_count()
        if chunk_count == 0:
            print("âŒ No chunks found in Elasticsearch. Please check your index.")
            return
        
        # Step 2: Transform ES chunks to KG format
        print(f"\n2ï¸âƒ£ Transforming ES chunks to KG format...")
        course_graph = transform_es_to_kg(course_id=course_id)
        
        if not course_graph["learning_objectives"]:
            print("âŒ No learning objectives generated. Check your ES data.")
            return
        
        # Step 3: Insert KG into Neo4j
        print(f"\n3ï¸âƒ£ Inserting KG into Neo4j...")
        insert_course_kg_to_neo4j(course_graph)
        print("âœ… Knowledge Graph successfully inserted into Neo4j")
        
        # Step 4: Generate PLT (optional)
        if generate_plt:
            print(f"\n4ï¸âƒ£ Generating Personalized Learning Tree for {learner_id}...")
            plt_result = run_plt_generator()
            plt = plt_result["final_plt"]
            insert_plt_to_neo4j(plt, clear_existing=clear_existing)
            print("âœ… Personalized Learning Tree generated successfully!")
            print(f"ğŸ“Š Generated {len(plt['learning_path'])} learning steps")
        
        print(f"\nğŸ‰ Pipeline completed successfully!")
        print(f"ğŸ“š Course: {course_id}")
        print(f"ğŸ“Š Learning Objectives: {len(course_graph['learning_objectives'])}")
        print(f"ğŸ§  Knowledge Components: {sum(len(lo.get('kcs', [])) for lo in course_graph['learning_objectives'])}")
        if generate_plt:
            print(f"ğŸ‘¤ PLT generated for learner: {learner_id}")

    except Exception as e:
        print(f"âŒ ES Pipeline failed: {e}")
        import traceback
        traceback.print_exc()

def run_unified_pipeline():
    """Legacy unified pipeline function (redirects to automatic pipeline)"""
    print("ğŸ”„ Redirecting to automatic pipeline...")
    print("Use 'python main.py auto' for the new automatic pipeline interface.")
    
    # Provide basic unified execution
    try:
        result = run_automatic_pipeline(
            content_source="elasticsearch", 
            generate_plt=True
        )
        
        if result["status"] == "completed":
            print("âœ… Unified pipeline completed!")
        else:
            print(f"âŒ Unified pipeline failed: {result.get('error')}")
            
    except Exception as e:
        print(f"âŒ Unified pipeline failed: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(__doc__)
        print("\nFACULTY WORKFLOWS (Primary):")
        print("  python main.py faculty-start --course_id CSN --faculty_id PROF_123")
        print("  python main.py faculty-approve --course_id CSN --action approve")
        print("  python main.py faculty-confirm --course_id CSN --action confirm")
        print("  python main.py faculty-finalize --course_id CSN --action finalize")
        print("  python main.py faculty-status --course_id CSN")
        print("  python main.py learner-plt --course_id CSN --learner_id R001")
        print("\nAUTOMATIC PIPELINES:")
        print("  python main.py auto                           # Complete automatic pipeline")
        print("  python main.py auto --course_id CSN          # Auto pipeline for course CSN")
        print("  python main.py content --course_id CSN       # Content-only pipeline")
        print("  python main.py learner --learner_id R001     # Learner-only pipeline")
        print("\nTECHNICAL COMMANDS:")
        print("  python main.py cross --course_id CSN --learner_id R001  # Cross-subsystem workflow")
        print("  python main.py services --list               # List all services")
        print("  python main.py services --subsystem content  # List content services")
        print("\nLEGACY COMMANDS (Backward Compatibility):")
        print("  python main.py stage1|stage2|plt|es|unified")
        sys.exit(1)

    command = sys.argv[1].lower()
    
    # NEW SEMI-AUTOMATIC FACULTY APPROVAL COMMANDS
    if command == "faculty-start":
        import argparse
        parser = argparse.ArgumentParser(description="Start Faculty Approval Workflow")
        parser.add_argument("--course_id", default=get_default_course_id(), help="Course identifier")
        parser.add_argument("--faculty_id", required=True, help="Faculty member identifier")
        parser.add_argument("--source", choices=["pdf", "elasticsearch", "llm_generated"],
                           default="elasticsearch", help="Content source type")
        parser.add_argument("--file_path", help="PDF file path (for PDF source)")
        parser.add_argument("--es_index", default="advanced_docs_elasticsearch_v2", help="ES index")
        parser.add_argument("--raw_content", help="Raw content (for LLM generated)")
        
        args = parser.parse_args(sys.argv[2:])
        run_faculty_start_cmd(args)
        
    elif command == "faculty-approve-course":
        import argparse
        parser = argparse.ArgumentParser(description="Faculty Approve Course Initialization")
        parser.add_argument("--course_id", required=True, help="Course identifier")
        parser.add_argument("--action", choices=["approve", "reject"], required=True,
                           help="Faculty action")
        parser.add_argument("--comments", help="Faculty comments")
        
        args = parser.parse_args(sys.argv[2:])
        run_faculty_approve_course_cmd(args)
        
    elif command == "faculty-approve":
        import argparse
        parser = argparse.ArgumentParser(description="Faculty Approve Learning Objectives")
        parser.add_argument("--course_id", required=True, help="Course identifier")
        parser.add_argument("--action", choices=["approve", "edit", "reject"], required=True,
                           help="Faculty action")
        parser.add_argument("--comments", help="Faculty comments")
        
        args = parser.parse_args(sys.argv[2:])
        run_faculty_approve_cmd(args)
        
    elif command == "faculty-confirm":
        import argparse
        parser = argparse.ArgumentParser(description="Faculty Confirm Course Structure")
        parser.add_argument("--course_id", required=True, help="Course identifier")
        parser.add_argument("--action", choices=["confirm", "edit", "reject"], required=True,
                           help="Faculty action")
        parser.add_argument("--comments", help="Faculty comments")
        
        args = parser.parse_args(sys.argv[2:])
        run_faculty_confirm_cmd(args)
        
    elif command == "faculty-finalize":
        import argparse
        parser = argparse.ArgumentParser(description="Faculty Finalize Knowledge Graph")
        parser.add_argument("--course_id", required=True, help="Course identifier")
        parser.add_argument("--action", choices=["finalize", "edit", "reject"], required=True,
                           help="Faculty action")
        parser.add_argument("--comments", help="Faculty comments")
        
        args = parser.parse_args(sys.argv[2:])
        run_faculty_finalize_cmd(args)
        
    elif command == "learner-plt":
        import argparse
        parser = argparse.ArgumentParser(description="Generate PLT for Learner (after faculty workflow)")
        parser.add_argument("--course_id", required=True, help="Course identifier")
        parser.add_argument("--learner_id", required=True, help="Learner identifier")
        parser.add_argument("--learning_style", choices=["visual", "auditory", "kinesthetic"], 
                           help="Learner's learning style")
        parser.add_argument("--experience_level", choices=["beginner", "intermediate", "advanced"],
                           help="Learner's experience level")
        parser.add_argument("--preferences", help="Additional learner preferences (JSON string)")
        
        args = parser.parse_args(sys.argv[2:])
        run_learner_plt_cmd(args)
        
    elif command == "faculty-status":
        import argparse
        parser = argparse.ArgumentParser(description="Check Faculty Workflow Status")
        parser.add_argument("--course_id", required=True, help="Course identifier")
        
        args = parser.parse_args(sys.argv[2:])
        run_faculty_status_cmd(args)
        
    elif command == "cross":
        import argparse
        parser = argparse.ArgumentParser(description="Run Cross-Subsystem Workflow")
        parser.add_argument("--course_id", default=get_default_course_id(), help="Course identifier")
        parser.add_argument("--upload_type", choices=["pdf", "elasticsearch", "llm_generated"],
                           default="elasticsearch", help="Content upload type")
        parser.add_argument("--file_path", help="PDF file path (for pdf upload type)")
        parser.add_argument("--es_index", default="advanced_docs_elasticsearch_v2",
                           help="Elasticsearch index (for elasticsearch upload type)")
        parser.add_argument("--learner_id", help="Learner ID for cross-subsystem PLT generation")
        
        args = parser.parse_args(sys.argv[2:])
        run_cross_subsystem_workflow_cmd(args)
        
    elif command == "services":
        import argparse
        parser = argparse.ArgumentParser(description="List Registered Services")
        parser.add_argument("--list", action="store_true", help="List all services")
        parser.add_argument("--subsystem", choices=["content", "learner", "sme", "analytics"],
                           help="Filter by subsystem")
        
        args = parser.parse_args(sys.argv[2:])
        
        if args.list or not args.subsystem:
            # If --list is specified or no subsystem filter, show all services
            register_all_services()
            registry = get_service_registry()
            
            print("ğŸ”§ Service Registry - All Registered Services")
            print("=" * 60)
            
            # List all services by subsystem
            for subsystem_type in ["content", "learner", "sme", "analytics"]:
                print(f"\nğŸ“š {subsystem_type.upper()} SUBSYSTEM:")
                print("-" * 40)
                
                services = registry.list_services()
                for service_id, service_info in services.items():
                    if service_info["subsystem"] == subsystem_type:
                        print(f"  ğŸ”§ {service_id}")
                        print(f"     Name: {service_info['name']}")
                        print(f"     Description: {service_info['description']}")
                        print(f"     Dependencies: {service_info['dependencies']}")
                        print(f"     Required Inputs: {service_info['required_inputs']}")
                        print(f"     Provided Outputs: {service_info['provided_outputs']}")
                        print()
            
            print("=" * 60)
            print(f"Total Services Registered: {len(registry.services)}")
        else:
            # Use the proper list_services_cmd for subsystem filtering
            list_services_cmd(args)

    # EXISTING AUTOMATIC COMMANDS (unchanged)
    elif command == "auto":
        import argparse
        parser = argparse.ArgumentParser(description="Automatic LangGraph Pipeline")
        parser.add_argument("--course_id", default=get_default_course_id(), help="Course identifier")
        parser.add_argument("--source", choices=["pdf", "elasticsearch", "llm_generated"], 
                           default="elasticsearch", help="Content source type")
        parser.add_argument("--learner_id", default=get_default_learner_id(), help="Learner identifier")
        parser.add_argument("--file_path", help="PDF file path (for PDF source)")
        parser.add_argument("--es_index", default="advanced_docs_elasticsearch_v2", help="ES index")
        parser.add_argument("--raw_content", help="Raw content (for LLM generated)")
        parser.add_argument("--no-plt", dest="generate_plt", action="store_false", help="Skip PLT generation")
        
        args = parser.parse_args(sys.argv[2:])
        run_automatic_pipeline_cmd(args)
        
    elif command == "content":
        import argparse
        parser = argparse.ArgumentParser(description="Content-Only Automatic Pipeline")
        parser.add_argument("--course_id", default=get_default_course_id(), help="Course identifier")
        parser.add_argument("--source", choices=["pdf", "elasticsearch", "llm_generated"], 
                           default="elasticsearch", help="Content source type")
        parser.add_argument("--file_path", help="PDF file path (for PDF source)")
        parser.add_argument("--es_index", default="advanced_docs_elasticsearch_v2", help="ES index")
        parser.add_argument("--raw_content", help="Raw content (for LLM generated)")
        
        args = parser.parse_args(sys.argv[2:])
        run_content_only_cmd(args)
        
    elif command == "learner":
        import argparse
        parser = argparse.ArgumentParser(description="Learner-Only Automatic Pipeline")
        parser.add_argument("--course_id", default=get_default_course_id(), help="Course identifier")
        parser.add_argument("--learner_id", default=get_default_learner_id(), help="Learner identifier")
        parser.add_argument("--learner_profile", help="JSON string of learner profile")
        
        args = parser.parse_args(sys.argv[2:])
        run_learner_only_cmd(args)
        
    # LEGACY COMMANDS (still supported)
    elif command == "stage1":
        print("ğŸ” Running Stage 1: Manual Content Processing Pipeline")
        print("=" * 50)
        print("ğŸ“‹ Starting Course Manager â†’ Content Processing workflow...")
        
        # Use the corrected microservices flow via Universal Orchestrator
        from orchestrator.universal_orchestrator import run_cross_subsystem_workflow
        from orchestrator.state import SubsystemType
        
        # Create manual workflow state
        initial_state = {
            "course_id": "MANUAL_COURSE_" + str(int(time.time())),
            "faculty_id": "MANUAL_FACULTY", 
            "workflow_type": "course_initialization",
            "upload_type": "manual_content",
            "manual_mode": True
        }
        
        print(f"ğŸ¯ Manual Course ID: {initial_state['course_id']}")
        print(f"ğŸ‘¨â€ğŸ« Manual Faculty: {initial_state['faculty_id']}")
        print("ğŸ“‹ This will trigger Course Manager to collect faculty inputs...")
        print()
        
        # Run the corrected microservices flow
        result = run_cross_subsystem_workflow(SubsystemType.CONTENT, **initial_state)
        
        print("âœ… Stage 1 completed!")
        print(f"ğŸ“Š Course Manager executed with faculty input collection")
        print(f"ğŸ¯ Result: {result.get('course_manager_result', {}).get('status', 'Unknown')}")
        
    elif command == "stage2":
        print("ğŸ¯ Running Stage 2: Learning Process & Instruction Pipeline")
        print("=" * 50)
        
        content = """
        Learning Objective: Understand virtual memory concepts and implementation
        Knowledge Components: Virtual memory mapping, page tables, memory allocation
        """
        messages = [HumanMessage(content=content)]
        
        graph = build_graph_stage_2()
        result = graph.invoke({"messages": messages})
        
        print("âœ… Stage 2 completed!")
        print(f"ğŸ“Š Generated {len(result['messages'])} agent responses")
        
    elif command == "plt":
        run_plt_pipeline()
        
    elif command == "es":
        run_es_pipeline()
        
    elif command == "unified":
        run_unified_pipeline()
        
    else:
        print(f"âŒ Unknown command: {command}")
        print(__doc__)
        sys.exit(1)